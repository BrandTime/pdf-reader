[TOC]
# 算法
## 封面
## 作者简介
## 数字版权声明
## 彩插
## 扉页
## 版权页
## 版权声明
## 献词
## 译者序
## 前言
## 目录
## 第1章    基础
### 1.1　基础编程模型
#### 1.1.1　Java程序的基本结构
#### 1.1.2　原始数据类型与表达式
##### 1.1.2.1    表达式
##### 1.1.2.2　类型转换
##### 1.1.2.3　比较
##### 1.1.2.4　其他原始类型
#### 1.1.3　语句
##### 1.1.3.1　声明语句
##### 1.1.3.2　赋值语句
##### 1.1.3.3　条件语句
##### 1.1.3.4　循环语句
#### 1.1.4　简便记法
##### 1.1.4.1　声明并初始化
##### 1.1.4.2　隐式赋值
##### 1.1.4.3　单语句代码段
##### 1.1.4.4　for语句
#### 1.1.5　数组
##### 1.1.5.1　创建并初始化数组
##### 1.1.5.2　简化写法
##### 1.1.5.3　使用数组
##### 1.1.5.4　起别名
##### 1.1.5.5　二维数组
#### 1.1.6　静态方法
##### 1.1.6.1　静态方法
##### 1.1.6.2　调用静态方法
##### 1.1.6.3　方法的性质
##### 1.1.6.4　递归
##### 1.1.6.5　基础编程模型
##### 1.1.6.6　模块化编程
##### 1.1.6.7　单元测试
##### 1.1.6.8　外部库
#### 1.1.7　API
##### 1.1.7.1　举例
##### 1.1.7.2　Java库
##### 1.1.7.3　我们的标准库
##### 1.1.7.4　你自己编写的库
#### 1.1.8　字符串
##### 1.1.8.1　字符串拼接
##### 1.1.8.2　类型转换
##### 1.1.8.3　自动转换
##### 1.1.8.4　命令行参数
#### 1.1.9　输入输出
##### 1.1.9.1　命令和参数
##### 1.1.9.2　标准输出
##### 1.1.9.3　格式化输出
##### 1.1.9.4　标准输入
##### 1.1.9.5　重定向与管道
##### 1.1.9.6　基于文件的输入输出
##### 1.1.9.7　标准绘图库（基本方法）
##### 1.1.9.8　标准绘图库（控制方法）
#### 1.1.10　二分查找
##### 1.1.10.1　二分查找
##### 1.1.10.2　开发用例
##### 1.1.10.3　白名单过滤
##### 1.1.10.4　性能
#### 1.1.11　展望
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 1.2　数据抽象
#### 1.2.1　使用抽象数据类型
##### 1.2.1.1　抽象数据类型的API
##### 1.2.1.2　继承的方法
##### 1.2.1.3　用例代码
##### 1.2.1.4　对象
##### 1.2.1.5　创建对象
##### 1.2.1.6　调用实例方法
##### 1.2.1.7　使用对象
##### 1.2.1.8　赋值语句
##### 1.2.1.9　将对象作为参数
##### 1.2.1.10　将对象作为返回值
##### 1.2.1.11　数组也是对象
##### 1.2.1.12　对象的数组
#### 1.2.2　抽象数据类型举例
##### 1.2.2.1　几何对象
##### 1.2.2.2　信息处理
##### 1.2.2.3　字符串
##### 1.2.2.4　再谈输入输出
#### 1.2.3　抽象数据类型的实现
##### 1.2.3.1　实例变量
##### 1.2.3.2　构造函数
##### 1.2.3.3　实例方法
##### 1.2.3.4　作用域
##### 1.2.3.5　API、用例与实现
#### 1.2.4　更多抽象数据类型的实现
##### 1.2.4.1　日期
##### 1.2.4.2　维护多个实现
##### 1.2.4.3　累加器
##### 1.2.4.4　可视化的累加器
#### 1.2.5　数据类型的设计
##### 1.2.5.1　封装
##### 1.2.5.2　设计API
##### 1.2.5.3　算法与抽象数据类型
##### 1.2.5.4　接口继承
##### 1.2.5.5　实现继承
##### 1.2.5.6　字符串表示的习惯
##### 1.2.5.7　封装类型
##### 1.2.5.8　等价性
##### 1.2.5.9　内存管理
##### 1.2.5.10　不可变性
##### 1.2.5.11　契约式设计
##### 1.2.5.12　异常与错误
##### 1.2.5.13　断言
##### 1.2.5.14　小结
#### 答疑
#### 练习
#### 提高题
### 1.3　背包、队列和栈
#### 1.3.1　API
##### 1.3.1.1　泛型
##### 1.3.1.2　自动装箱
##### 1.3.1.3　可迭代的集合类型
##### 1.3.1.4　背包
##### 1.3.1.5　先进先出队列
##### 1.3.1.6　下压栈
##### 1.3.1.7　算术表达式求值
#### 1.3.2　集合类数据类型的实现
##### 1.3.2.1　定容栈
##### 1.3.2.2　泛型
##### 1.3.2.3　调整数组大小
##### 1.3.2.4　对象游离
##### 1.3.2.5　迭代
#### 1.3.3　链表
##### 1.3.3.1　结点记录
##### 1.3.3.2　构造链表
##### 1.3.3.3　在表头插入结点
##### 1.3.3.4　从表头删除结点
##### 1.3.3.5　在表尾插入结点
##### 1.3.3.6　其他位置的插入和删除操作
##### 1.3.3.7　遍历
##### 1.3.3.8　栈的实现
##### 1.3.3.9　队列的实现
##### 1.3.3.10　背包的实现
#### 1.3.4　综述
#### 答疑
#### 练习
#### 链表练习
#### 提高题
### 1.4　算法分析
#### 1.4.1　科学方法
#### 1.4.2　观察
##### 1.4.2.1　举例
##### 1.4.2.2　计时器
##### 1.4.2.3　实验数据的分析
#### 1.4.3　数学模型
##### 1.4.3.1　近似
##### 1.4.3.2　近似运行时间
##### 1.4.3.3　对增长数量级的猜想
##### 1.4.3.4　算法的分析
##### 1.4.3.5　成本模型
##### 1.4.3.6　总结
#### 1.4.4　增长数量级的分类
##### 1.4.4.1　常数级别
##### 1.4.4.2　对数级别
##### 1.4.4.3　线性级别
##### 1.4.4.4　线性对数级别
##### 1.4.4.5　平方级别
##### 1.4.4.6　立方级别
##### 1.4.4.7　指数级别
#### 1.4.5　设计更快的算法
##### 1.4.5.1　热身运动 2-sum
##### 1.4.5.2　3-sum问题的快速算法
##### 1.4.5.3　下界
#### 1.4.6　倍率实验
##### 1.4.6.1　评估它解决大型问题的可行性
##### 1.4.6.2　评估使用更快的计算机所产生的价值
#### 1.4.7　注意事项
##### 1.4.7.1　大常数
##### 1.4.7.2　非决定性的内循环
##### 1.4.7.3　指令时间
##### 1.4.7.4　系统因素
##### 1.4.7.5　不分伯仲
##### 1.4.7.6　对输入的强烈依赖
##### 1.4.7.7　多个问题参量
#### 1.4.8　处理对于输入的依赖
##### 1.4.8.1　输入模型
##### 1.4.8.2　对最坏情况下的性能的保证
##### 1.4.8.3　随机化算法
##### 1.4.8.4　操作序列
##### 1.4.8.5　均摊分析
#### 1.4.9　内存
##### 1.4.9.1　对象
##### 1.4.9.2　链表
##### 1.4.9.3　数组
##### 1.4.9.4　字符串对象
##### 1.4.9.5　字符串的值和子字符串
##### 1.4.10　展望
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 1.5　案例研究：union-find算法
#### 1.5.1　动态连通性
##### 1.5.1.1　网络
##### 1.5.1.2　变量名等价性
##### 1.5.1.3　数学集合
#### 1.5.2　实现
##### 1.5.2.1　quick-find算法
##### 1.5.2.2　quick-find算法的分析
##### 1.5.2.3　quick-union算法
##### 1.5.2.4　森林的表示
##### 1.5.2.5　quick-union算法的分析
##### 1.5.2.6　加权quick-union算法
##### 1.5.2.7　加权quick-union算法的分析
##### 1.5.2.8　最优算法
##### 1.5.2.9　均摊成本的图像
#### 1.5.3　展望
#### 答疑
#### 练习
#### 提高题
#### 实验题
## 第2章　排序
### 2.1　初级排序算法
#### 2.1.1　游戏规则
##### 2.1.1.1　验证
##### 2.1.1.2　运行时间
##### 2.1.1.3　额外的内存使用
##### 2.1.1.4　数据类型
#### 2.1.2　选择排序
#### 2.1.3　插入排序
#### 2.1.4　排序算法的可视化
#### 2.1.5　比较两种排序算法
#### 2.1.6　希尔排序
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 2.2　归并排序
#### 2.2.1　原地归并的抽象方法
#### 2.2.2　自顶向下的归并排序
##### 2.2.2.1　 对小规模子数组使用插入排序
##### 2.2.2.2　测试数组是否已经有序
##### 2.2.2.3　不将元素复制到辅助数组
#### 2.2.3　自底向上的归并排序
#### 2.2.4　排序算法的复杂度
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 2.3　快速排序
#### 2.3.1　基本算法
##### 2.3.1.1　原地切分
##### 2.3.1.2　别越界
##### 2.3.1.3　保持随机性
##### 2.3.1.4　终止循环
##### 2.3.1.5　处理切分元素值有重复的情况
##### 2.3.1.6　终止递归
#### 2.3.2　性能特点
#### 2.3.3　算法改进
##### 2.3.3.1　切换到插入排序
##### 2.3.3.2　三取样切分
##### 2.3.3.3　熵最优的排序
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 2.4　优先队列
#### 2.4.1　API
#### 2.4.2　初级实现
##### 2.4.2.1　数组实现（无序）
##### 2.4.2.2　数组实现（有序）
##### 2.4.2.3　链表表示法
#### 2.4.3　堆的定义
#### 2.4.4　堆的算法
##### 2.4.4.1　由下至上的堆有序化（上浮）
##### 2.4.4.2　由上至下的堆有序化（下沉）
##### 2.4.4.3　多叉堆
##### 2.4.4.4　调整数组大小
##### 2.4.4.5　元素的不可变性
##### 2.4.4.6　索引优先队列
##### 2.4.4.7　索引优先队列用例
#### 2.4.5　堆排序
##### 2.4.5.1　堆的构造
##### 2.4.5.2　下沉排序
##### 2.4.5.3　先下沉后上浮
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 2.5　应用
#### 2.5.1　将各种数据排序
##### 2.5.1.1　交易事务
##### 2.5.1.2　指针排序
##### 2.5.1.3　不可变的键
##### 2.5.1.4　廉价的交换
##### 2.5.1.5　多种排序方法
##### 2.5.1.6　多键数组
##### 2.5.1.7　使用比较器实现优先队列
##### 2.5.1.8　稳定性
#### 2.5.2　我应该使用哪种排序算法
##### 2.5.2.1　将原始类型数据排序
##### 2.5.2.2　Java系统库的排序算法
#### 2.5.3　问题的归约
##### 2.5.3.1　找出重复元素：
##### 2.5.3.2　排名
##### 2.5.3.3　优先队列
##### 2.5.3.4　中位数与顺序统计
#### 2.5.4　排序应用一览
##### 2.5.4.1　商业计算
##### 2.5.4.2　信息搜索
##### 2.5.4.3　运筹学
##### 2.5.4.4　事件驱动模拟
##### 2.5.4.5　数值计算
##### 2.5.4.6　组合搜索
#### 答疑
#### 练习
#### 提高题
#### 实验题
## 第3章　查找
### 3.1　符号表
#### 3.1.1　API
##### 3.1.1.1　泛型
##### 3.1.1.2　重复的键
##### 3.1.1.3　空（null）键
##### 3.1.1.4　空（null）值
##### 3.1.1.5　删除操作
##### 3.1.1.6　便捷方法
##### 3.1.1.7　迭代
##### 3.1.1.8　键的等价性
#### 3.1.2 　有序符号表
##### 3.1.2.1　最大键和最小键
##### 3.1.2.2　向下取整和向上取整
##### 3.1.2.3　排名和选择
##### 3.1.2.4　范围查找
##### 3.1.2.5　例外情况
##### 3.1.2.6　便捷方法
##### 3.1.2.7　（再谈）键的等价性
##### 3.1.2.8　成本模型
#### 3.1.3　用例举例
##### 3.1.3.1　行为测试用例
##### 3.1.3.2　性能测试用例
#### 3.1.4　无序链表中的顺序查找
#### 3.1.5　有序数组中的二分查找
##### 3.1.5.1　二分查找
##### 3.1.5.2　其他操作
#### 3.1.6　对二分查找的分析
#### 3.1.7　预览
#### 练习
#### 提高题
#### 实验题
### 3.2　二叉查找树
#### 3.2.1　基本实现
##### 3.2.1.1　数据表示
##### 3.2.1.2　查找
##### 3.2.1.3　插入
##### 3.2.1.4　递归
#### 3.2.2　分析
#### 3.2.3　有序性相关的方法与删除操作
##### 3.2.3.1　最大键和最小键
##### 3.2.3.2　向上取整和向下取整
##### 3.2.3.3　选择操作
##### 3.2.3.4　排名
##### 3.2.3.5　删除最大键和删除最小键
##### 3.2.3.6　删除操作
##### 3.2.3.7　范围查找
##### 3.2.3.8　性能分析
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 3.3　平衡查找树
#### 3.3.1　2-3 查找树
##### 3.3.1.1　查找
##### 3.3.1.2　向2- 结点中插入新键
##### 3.3.1.3　向一棵只含有一个3-结点的树中插入新键
##### 3.3.1.4　向一个父结点为2-结点的3-结点中插入新键
##### 3.3.1.5　向一个父结点为3-结点的3-结点中插入新键
##### 3.3.1.6　分解根结点
##### 3.3.1.7　局部变换
##### 3.3.1.8　全局性质
#### 3.3.2　红黑二叉查找树
##### 3.3.2.1　替换3-结点
##### 3.3.2.2　一种等价的定义
##### 3.3.2.3　一一对应
##### 3.3.2.4　颜色表示
##### 3.3.2.5　旋转
##### 3.3.2.6　在旋转后重置父结点的链接
##### 3.3.2.7　向单个2-结点中插入新键
##### 3.3.2.8　向树底部的2-结点插入新键
##### 3.3.2.9　向一棵双键树（即一个3-结点）中插入新键
##### 3.3.2.10　颜色转换
##### 3.3.2.11　根结点总是黑色
##### 3.3.2.12　向树底部的3-结点插入新键
##### 3.3.2.13　将红链接在树中向上传递
#### 3.3.3　实现
#### 3.3.4　删除操作
##### 3.3.4.1　自顶向下的2-3-4树
##### 3.3.4.2　删除最小键
##### 3.3.4.3　删除操作
#### 3.3.5　红黑树的性质
##### 3.3.5.1　性能分析
##### 3.3.5.2　有序符号表API
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 3.4　散列表
#### 3.4.1　散列函数
##### 3.4.1.1　典型的例子
##### 3.4.1.2　正整数
##### 3.4.1.3　浮点数
##### 3.4.1.4　字符串
##### 3.4.1.5　组合键
##### 3.4.1.6　Java的约定
##### 3.4.1.7　将hashCode()的返回值转化为一个数组索引
##### 3.4.1.8　自定义的hashCode()方法
##### 3.4.1.9　软缓存
#### 3.4.2　基于拉链法的散列表
##### 3.4.2.1　散列表的大小
##### 3.4.2.2　删除操作
##### 3.4.2.3　有序性相关的操作
#### 3.4.3　基于线性探测法的散列表
##### 3.4.3.1　删除操作
##### 3.4.3.2　键簇
##### 3.4.3.3　线性探测法的性能分析
#### 3.4.4　调整数组大小
##### 3.4.4.1　拉链法
##### 3.4.4.2　均摊分析
#### 3.4.5　内存使用
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 3.5　应用
#### 3.5.1　我应该使用符号表的哪种实现
##### 3.5.1.1　原始数据类型
##### 3.5.1.2　重复键
##### 3.5.1.3　Java标准库
#### 3.5.2　集合的API
##### 3.5.2.1　dedup
##### 3.5.2.2　白名单和黑名单
#### 3.5.3　字典类用例
#### 3.5.4　索引类用例
#### 3.5.5　稀疏向量
#### 答疑
#### 练习
#### 提高题
#### 实验题
## 第4章    图
### 4.1　无向图
#### 4.1.1　术语表
#### 4.1.2　表示无向图的数据类型
##### 4.1.2.1　图的几种表示方法
##### 4.1.2.2　邻接表的数据结构
##### 4.1.2.3　图的处理算法的设计模式
#### 4.1.3　深度优先搜索
##### 4.1.3.1　走迷宫
##### 4.1.3.2　热身
##### 4.1.3.3　单向通道
##### 4.1.3.4　跟踪深度优先搜索
##### 4.1.3.5　深度优先搜索的详细轨迹
#### 4.1.4　寻找路径
##### 4.1.4.1　实现
##### 4.1.4.2　详细轨迹
#### 4.1.5　广度优先搜索
#### 4.1.6　连通分量
##### 4.1.6.1　实现
##### 4.1.6.2　union-find算法
#### 4.1.7　符号图
##### 4.1.7.1　API
##### 4.1.7.2　测试用例
##### 4.1.7.3　实现
##### 4.1.7.4　间隔的度数
#### 4.1.8　总结
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 4.2　有向图
#### 4.2.1　术语
#### 4.2.2　有向图的数据类型
##### 4.2.2.1　有向图的表示
##### 4.2.2.2　输入格式
##### 4.2.2.3　有向图取反
##### 4.2.2.4　顶点的符号名
#### 4.2.3　有向图中的可达性
##### 4.2.3.1　标记-清除的垃圾收集
##### 4.2.3.2　有向图的寻路
#### 4.2.4　环和有向无环图
##### 4.2.4.1　调度问题
##### 4.2.4.2　有向图中的环
##### 4.2.4.3　顶点的深度优先次序与拓扑排序
#### 4.2.5　有向图中的强连通性
##### 4.2.5.1　强连通分量
##### 4.2.5.2　应用举例
##### 4.2.5.3　Kosaraju算法
##### 4.2.5.4　再谈可达性
#### 4.2.6　总结
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 4.3　最小生成树
#### 4.3.1　原理
##### 4.3.1.1　切分定理
##### 4.3.1.2　贪心算法
#### 4.3.2　加权无向图的数据类型
##### 4.3.2.1　用权重来比较边
##### 4.3.2.2　平行边
##### 4.3.2.3　自环
#### 4.3.3　最小生成树的API和测试用例
##### 4.3.3.1　测试用例
##### 4.3.3.2　测试数据
#### 4.3.4　Prim算法
##### 4.3.4.1　数据结构
##### 4.3.4.2　维护横切边的集合
##### 4.3.4.3　实现
##### 4.3.4.4　运行时间
#### 4.3.5　Prim算法的即时实现
#### 4.3.6　Kruskal算法
#### 4.3.7　展望
##### 4.3.7.1　历史资料
##### 4.3.7.2　线性的最小生成树算法？
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 4.4　最短路径
#### 4.4.1　最短路径的性质
#### 4.4.2　加权有向图的数据结构
##### 4.4.2.1　最短路径的API
##### 4.4.2.2　测试用例
##### 4.4.2.3　最短路径的数据结构
##### 4.4.2.4　边的松弛
##### 4.4.2.5　顶点的松弛
##### 4.4.2.6　为用例准备的查询方法
#### 4.4.3　最短路径算法的理论基础
##### 4.4.3.1　最优性条件
##### 4.4.3.2　验证
##### 4.4.3.3　通用算法
#### 4.4.4　Dijkstra算法
##### 4.4.4.1　数据结构
##### 4.4.4.2　换一个角度看问题
##### 4.4.4.3　变种
#### 4.4.5　无环加权有向图中的最短路径算法
##### 4.4.5.1　最长路径
##### 4.4.5.2　并行任务调度
##### 4.4.5.3　相对最后期限限制下的并行任务调度
#### 4.4.6　一般加权有向图中的最短路径问题
##### 4.4.6.1　尝试Ⅰ
##### 4.4.6.2　尝试Ⅱ
##### 4.4.6.3　负权重的环
##### 4.4.6.4　尝试Ⅲ
##### 4.4.6.5　基于队列的Bellman-Ford算法
##### 4.4.6.6　实现
##### 4.4.6.7　负权重的边
##### 4.4.6.8　负权重环的检测
##### 4.4.6.9　套汇
#### 4.4.7　展望
#### 答疑
#### 练习
#### 提高题
#### 实验题
## 第5章　字符串
### 5.0.1　游戏规则
### 5.0.2　字母表
### 5.1　字符串排序
#### 5.1.1　键索引计数法
##### 5.1.1.1　频率统计
##### 5.1.1.2　将频率转换为索引
##### 5.1.1.3　数据分类
##### 5.1.1.4　回写
#### 5.1.2　低位优先的字符串排序
#### 5.1.3　高位优先的字符串排序
##### 5.1.3.1　对字符串末尾的约定
##### 5.1.3.2　指定的字母表
##### 5.1.3.3　小型子数组
##### 5.1.3.4　等值键
##### 5.1.3.5　额外空间
##### 5.1.3.6　随机字符串模型
##### 5.1.3.7　性能
#### 5.1.4　三向字符串快速排序
##### 5.1.4.1　小型子数组
##### 5.1.4.2　有限的字母表
##### 5.1.4.3　随机化
##### 5.1.4.4　性能
##### 5.1.4.5　举例：网站日志
#### 5.1.5　字符串排序算法的选择
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 5.2　单词查找树
#### 5.2.1　单词查找树
##### 5.2.1.1　基本性质
##### 5.2.1.2　单词查找树中的查找操作
##### 5.2.1.3　单词查找树中的插入操作
##### 5.2.1.4　结点的表示
##### 5.2.1.5　大小
##### 5.2.1.6　查找所有键
##### 5.2.1.7　通配符匹配
##### 5.2.1.8　最长前缀
##### 5.2.1.9　删除操作
##### 5.2.1.10　字母表
#### 5.2.2　单词查找树的性质
##### 5.2.2.1　最坏情况下查找和插入操作的时间界限
##### 5.2.2.2　查找未命中的预期时间界限
##### 5.2.2.3　空间
##### 5.2.2.4　单向分支
#### 5.2.3　三向单词查找树
#### 5.2.4　三向单词查找树的性质
##### 5.2.4.1　空间
##### 5.2.4.2　查找成本
##### 5.2.4.3　字母表
##### 5.2.4.4　前缀匹配、查找所有键和通配符匹配
##### 5.2.4.5　删除操作
##### 5.2.4.6　混合三向单词查找树
##### 5.2.4.7　单向分支
#### 5.2.5　应该使用字符串符号表的哪种实现
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 5.3　子字符串查找
#### 5.3.1　历史简介
#### 5.3.2　暴力子字符串查找算法
#### 5.3.3　Knuth-Morris-Pratt子字符串查找算法
##### 5.3.3.1　模式指针的回退
##### 5.3.3.2　KMP查找算法
##### 5.3.3.3　DFA模拟
##### 5.3.3.4　构造DFA
#### 5.3.4　Boyer-Moore字符串查找算法
##### 5.3.4.1　启发式的处理不匹配的字符
##### 5.3.4.2　起点
##### 5.3.4.3　子字符串的查找
#### 5.3.5　Rabin-Karp指纹字符串查找算法
##### 5.3.5.1　基本思想
##### 5.3.5.2　计算散列函数
##### 5.3.5.3　关键思想
##### 5.3.5.4　实现
##### 5.3.5.5　小技巧：用蒙特卡洛法验证正确性
#### 5.3.6　总结
#### 答疑
#### 练习
#### 提高题
#### 实验题
### 5.4　正则表达式
#### 5.4.1　使用正则表达式描述模式
##### 5.4.1.1　连接操作
##### 5.4.1.2　或操作
##### 5.4.1.3　闭包操作
##### 5.4.1.4　括号
#### 5.4.2　缩略写法
##### 5.4.2.1　字符集描述符
##### 5.4.2.2　闭包的简写
##### 5.4.2.3　转义序列
#### 5.4.3　正则表达式的实际应用
##### 5.4.3.1　子字符串查找
##### 5.4.3.2　合法性检查
##### 5.4.3.3　程序员的工具箱
##### 5.4.3.4　基因组
##### 5.4.3.5　搜索
##### 5.4.3.6　正则表达式的可能性
##### 5.4.3.7　局限
#### 5.4.4　非确定有限状态自动机
#### 5.4.5　模拟NFA的运行
##### 5.4.5.1　自动机的表示
##### 5.4.5.2　NFA的模拟与可达性
#### 5.4.6　构造与正则表达式对应的NFA
##### 5.4.6.1　连接操作
##### 5.4.6.2　括号
##### 5.4.6.3　闭包操作
##### 5.4.6.4　“或”表达式
#### 答疑
#### 练习
#### 提高题
### 5.5　数据压缩
#### 5.5.1　游戏规则
#### 5.5.2　读写二进制数据
##### 5.5.2.1　二进制的输入输出
##### 5.5.2.2　举例
##### 5.5.2.3　二进制转储
##### 5.5.2.4　ASCII编码
#### 5.5.3　局限
##### 5.5.3.1　通用数据压缩
##### 5.5.3.2　不可判定性
#### 5.5.4　热身运动：基因组
##### 5.5.4.1　基因数据
##### 5.5.4.2　双位编码压缩
##### 5.5.4.3　双位编码展开
#### 5.5.5　游程编码
##### 5.5.5.1　位图
##### 5.5.5.2　实现
##### 5.5.5.3　提高位图的分辨率
#### 5.5.6　霍夫曼压缩
##### 5.5.6.1　变长前缀码
##### 5.5.6.2　前缀码的单词查找树
##### 5.5.6.3　概述
##### 5.5.6.4　单词查找树的结点
##### 5.5.6.5　使用前缀码展开
##### 5.5.6.6　使用前缀码压缩
##### 5.5.6.7　单词查找树的构造
##### 5.5.6.8　最优性
##### 5.5.6.9　写入和读取单词查找树
##### 5.5.6.10　霍夫曼压缩的实现
##### 5.5.6.11　LZW压缩算法
##### 5.5.6.12　LZW压缩举例
##### 5.5.6.13　LZW的单词查找树
##### 5.5.6.14　LZW压缩的展开
##### 5.5.6.15　特殊情况
##### 5.5.6.16　实现
#### 答疑
#### 练习
#### 提高题
## 第6章　背景
### 6.0.1　事件驱动模拟
#### 6.0.1.1　刚性球体模型
#### 6.0.1.2　时间驱动模拟
#### 6.0.1.3　事件驱动模拟
#### 6.0.1.4　碰撞预测
#### 6.0.1.5　碰撞计算
#### 6.0.1.6　排除无效事件
#### 6.0.1.7　粒子
#### 6.0.1.8　事件
#### 6.0.1.9　模拟器代码
#### 6.0.1.10　性能
### 6.0.2　B-树
#### 6.0.2.1　成本模型
#### 6.0.2.2　B-树
#### 6.0.2.3　约定
#### 6.0.2.4　查找和插入
#### 6.0.2.5　数据表示
#### 6.0.2.6　性能
#### 6.0.2.7　空间需求
### 6.0.3　后缀数组
#### 6.0.3.1　最长重复子字符串
#### 6.0.3.2　暴力解法
#### 6.0.3.3　后缀排序
#### 6.0.3.4　定位字符串
#### 6.0.3.5　API及其用例
#### 6.0.3.6　实现
#### 6.0.3.7　性能
#### 6.0.3.8　改进的实现
### 6.0.4　网络流算法
#### 6.0.4.1　物理模型
#### 6.0.4.2　定义
#### 6.0.4.3　API
#### 6.0.4.4　Ford-Fulkerson算法
#### 6.0.4.5　最大流-最小切分定理
#### 6.0.4.6　剩余网络
#### 6.0.4.7　最短增广路径算法
#### 6.0.4.8　性能
### 6.0.5　问题归约
#### 6.0.5.1　排序问题
#### 6.0.5.2　最短路径问题
#### 6.0.5.3　最大流量问题
#### 6.0.5.4　线性规划
### 6.0.6　不可解性
#### 6.0.6.1　准备工作
#### 6.0.6.2　指数级别的运行时间
#### 6.0.6.3　搜索问题
#### 6.0.6.4　其他类型的问题
#### 6.0.6.5　简单的搜索问题
#### 6.0.6.6　非确定性
#### 6.0.6.7　主要问题
#### 6.0.6.8　多项式时间问题的相互归约
#### 6.0.6.9　NP-完全性
#### 6.0.6.10　Cook-Levin定理
#### 6.0.6.11　问题的分类
#### 6.0.6.12　处理NP-完全性
### 练习：碰撞模拟
### 练习：B-树
### 练习：后缀数组
### 练习：最大流问题
### 练习：问题的归约与不可解性
## 索引
## 延伸阅读
## 看完了
